Usage
=====

The ``Q`` Class
---------------

The ``Q`` implementation provided by this library contains a simple addition to that
of Django.

Creating a ``Q`` object works as usual::

    >>> from django_flexquery import Q
    >>> q = Q(size__lt=10)
    >>> q
    <Q: (AND: ('size__lt', 10))>

But this implementation adds a ``prefix()`` method, which allows prefixing some
related field's name to the lookup keys of an existing ``Q`` object. Since ``Q``
objects can be nested, this is done recursively.

An example::

    >>> q.prefix("fruits")
    <Q: (AND: ('fruits__size__lt', 10))>

Nothing more to it. The real power comes when using these ``Q`` objects with
``FlexQuery``.


The ``FlexQuery`` Class
-----------------------

The ``FlexQuery`` class provides two classmethods which can be used as decorators
for functions declared on a custom ``Manager`` or ``QuerySet``::

    from django_flexquery import FlexQuery, Manager, Q, QuerySet

    # It's crucial to inherit from the QuerySet class of django_flexquery, because
    # the FlexQuery's wouldn't make it over to a Manager derived using as_manager()
    # with the stock Django implementation. That's the only difference however.
    class FruitQuerySet(QuerySet):
        # Declare a function that filters a QuerySet in some way.
        @FlexQuery.from_queryset
        def small(queryset):
            return queryset.filter(size__lt=10)

        # Or declare a function that generates a Q object.
        @FlexQuery.from_q
        def large():
            return Q(size__gte=10)

``FruitQuerySet.small`` and ``FruitQuerySet.large`` are now sub-types of ``FlexQuery``
encapsulating the respective custom function.

You can then derive a ``Manager`` from ``FruitQuerySet`` in two ways, using the
known Django API::

    # Either use from_queryset() of the Manager class provided with this module.
    class FruitManager(Manager.from_queryset(FruitQuerySet)):
        ...

    # Or, if you don't want to add additional manager-only methods, create a Manager
    # instance inside your model definition straight away.
    class Fruit(Model):
        objects = FruitQuerySet.as_manager()
        ...

When we assume such a ``Manager`` being the default manager of a ``Fruit`` model
with a ``size`` field, we can now perform the following queries::

    Fruit.objects.small()
    Fruit.objects.filter(Fruit.objects.small.as_q())
    Fruit.objects.large()
    Fruit.objects.filter(Fruit.objects.large.as_q())

Internally, this is made possible by some metaclass and descriptor magic instantiating
the ``FlexQuery`` type whenever it is accessed as class attribute of a ``Manager``
or ``QuerySet`` object. The resulting ``FlexQuery`` instance will be tied to its
owner and use that for all its filtering.

A ``FlexQuery`` instance is directly callable (``Fruit.objects.small()``), which just
executes our custom filter function on the base ``QuerySet``. This is a well-known
usage pattern you might have come across often when writing custom Django model
managers or querysets.

However, ``FlexQuery`` also comes with an ``as_q()`` method,
which generates a ``Q`` object incorporating our custom filtering
(``Fruit.objects.filter(Fruit.objects.small.as_q())``), even though we just provided
a function that filters an existing ``QuerySet``. The ``FlexQuery`` can mediate
between these two and deliver what you need in your particular situation.


Conversion Costs
~~~~~~~~~~~~~~~~

Providing a standalone ``QuerySet`` filtered by the ``Q`` from a supplied ``Q``
function is a cheap operation. The ``Q`` object generated by your custom function is
simply applied to the base using ``QuerySet.filter()``, resulting in a new ``QuerySet``
you may either evaluate straight away or use to create a sub-query.

The other direction, wrapping the logic performed by a custom ``QuerySet`` filtering
function in ``a`` Q object, is however not so simple. Since the ``FlexQuery`` can't
know what your filter function does to the ``QuerySet``, it creates a ``Q`` object
of the form ``Q(pk__in=your_queryset_func(...))``, which results in a sub-query
being generated for sure.

As you can see, you are more flexible when creating the ``FlexQuery`` type from a
``Q`` function instead of a ``QuerySet`` filtering function whenever possible.


Why do I Need This?
-------------------

This approach enables you to declare logic for filtering once with the ``Manager``
or ``QuerySet`` of the model it belongs to. When combined with the prefix() method
of the extended Q object implementation, related models can then simply fetch the
generated Q object and prefix it with the related field's name in order to reuse it
in their own filtering code, without needing sub-queries. Think of something like::

    class TreeQuerySet(QuerySet):
        @FlexQuery.from_q
        def having_ripe_apples():
            return Q(kind="apple") & Fruid.objects.large.as_q().prefix("fruits")
